{"version":3,"sources":["auth-microservice.js"],"names":["express","require","ApolloServer","gql","jwt","cookieParser","cors","mongoose","bcrypt","config","app","use","origin","credentials","connect","process","env","MONGODB_URI","console","err","error","model","userSchema","_templateObject","module","exports","resolvers","Query","currentUser","__","token","req","cookies","username","verify","JWT_SECRET","currentUserType","_ref2","decoded","accountType","Mutation","login","_","_ref3","_ref4","password","res","user","regeneratorRuntime","async","_context","prev","next","awrap","User","findOne","log","sent","compare","Error","sign","expiresIn","cookie","httpOnly","maxAge","abrupt","stop","_ref5","firstName","lastName","email","hashedPassword","newUser","_context2","hash","save","logout","_ref6","clearCookie","server","typeDefs","match","start","then","applyMiddleware","listen","port","concat","graphqlPath"],"mappings":"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","file":"auth-microservice.min.js","sourcesContent":["// server/auth-microservice.js\r\nconst express = require('express');\r\nconst { ApolloServer, gql } = require('apollo-server-express');\r\nconst jwt = require('jsonwebtoken');\r\nconst cookieParser = require('cookie-parser');\r\nconst cors = require('cors');\r\nconst mongoose = require('mongoose');\r\nconst bcrypt = require('bcrypt');\r\nrequire('dotenv').config();\r\n//\r\nconst app = express();\r\n//\r\n// Add cors middleware\r\napp.use(cors({\r\n    origin: ['http://localhost:3000', 'http://localhost:3001',\r\n        'http://localhost:3002', 'http://localhost:3003', 'http://localhost:3004', 'https://studio.apollographql.com'\r\n    ], // Adjust the origin according to your micro frontends' host\r\n    credentials: true, // Allow cookies to be sent\r\n}));\r\napp.use(cookieParser());\r\n//\r\n// MongoDB connection setup\r\nmongoose.connect(process.env.MONGODB_URI)\r\n    .then(() => console.log(\"MongoDB connected\"))\r\n    .catch(err => console.error(\"MongoDB connection error:\", err));\r\n//\r\n// User schema definition\r\nconst userSchema = require('./userSchema');\r\n//\r\nconst User = mongoose.model('User', userSchema);\r\n//\r\nconst typeDefs = gql `\r\n  type User {\r\n    username: String!\r\n    password: String!\r\n    firstName: String!\r\n    lastName: String!\r\n    email: String!\r\n    accountType: String!\r\n  }\r\n\r\n  type Query {\r\n    currentUser: User\r\n    currentUserType: User\r\n  }\r\n  type Mutation {\r\n    login(username: String!, password: String!): Boolean\r\n    register(username: String!, password: String!, firstName: String!, lastName: String!, email: String!, accountType: String): Boolean\r\n    logout: Boolean\r\n  }\r\n`;\r\n\r\nmodule.exports = userSchema;\r\n\r\nconst resolvers = {\r\n    Query: {\r\n        currentUser: (_, __, { req }) => {\r\n            // Assuming the JWT token is sent via an HTTP-only cookie named 'token'\r\n            const token = req.cookies['token'];\r\n            if (!token) {\r\n                return null; // No user is logged in\r\n            }\r\n\r\n            try {\r\n                // Verify and decode the JWT. Note: Make sure to handle errors appropriately in a real app\r\n                const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n                return { username: decoded.username };\r\n            } catch (error) {\r\n                // Token verification failed\r\n                return null;\r\n            }\r\n        },\r\n\r\n        currentUserType: (_, __, { req }) => {\r\n            // Assuming the JWT token is sent via an HTTP-only cookie named 'token'\r\n            const token = req.cookies['token'];\r\n            if (!token) {\r\n                return null; // No user is logged in\r\n            }\r\n\r\n            try {\r\n                // Verify and decode the JWT. Note: Make sure to handle errors appropriately in a real app\r\n                const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n                console.log(\"decoded jwt token: \" + decoded.accountType);\r\n                return { accountType: decoded.accountType };\r\n            } catch (error) {\r\n                // Token verification failed\r\n                return null;\r\n            }\r\n        },\r\n    },\r\n    Mutation: {\r\n        login: async(_, { username, password }, { res }) => {\r\n            // In a real app, validate username and password against a database\r\n            const user = await User.findOne({ username });\r\n            if (!user) {\r\n                throw new Error('User not found');\r\n            }\r\n            const match = await bcrypt.compare(password, user.password);\r\n            if (!match) {\r\n                throw new Error('Invalid password');\r\n            }\r\n            //\r\n            const token = jwt.sign({ username: user.username, accountType: user.accountType }, process.env.JWT_SECRET, { expiresIn: '1d' });\r\n            res.cookie('token', token, {\r\n                httpOnly: true,\r\n                //sameSite: 'None',\r\n                // secure: true, // Set to true if your site is served over HTTPS\r\n                maxAge: 24 * 60 * 60 * 1000, // 1 day\r\n            });\r\n            return true;\r\n        },\r\n        register: async(_, { username, password, firstName, lastName, email, accountType }) => {\r\n            const existingUser = await User.findOne({ username });\r\n            if (existingUser) {\r\n                throw new Error('Username is already taken');\r\n            }\r\n\r\n            const hashedPassword = await bcrypt.hash(password, 10);\r\n            const newUser = new User({ username, password: hashedPassword, firstName, lastName, email, accountType });\r\n            await newUser.save();\r\n            return true;\r\n        },\r\n        logout: (_, __, { res }) => {\r\n            res.clearCookie('token');\r\n            return true;\r\n        }\r\n    },\r\n};\r\n//\r\nconst server = new ApolloServer({\r\n    typeDefs,\r\n    resolvers,\r\n    context: ({ req, res }) => ({ req, res }),\r\n});\r\nserver.start().then(() => {\r\n    server.applyMiddleware({ app, cors: false });\r\n    //\r\n    app.listen({ port: 4001 }, () =>\r\n        console.log(`ðŸš€ Auth Server ready at http://localhost:4001${server.graphqlPath}`)\r\n    );\r\n});"]}